Attribute VB_Name = "modLOC"
' ***************************************************************************
' Module:        modLOC
'
' Description:   This application will count lines of code for both Visual
'                Basic and C projects.  It will handle VB Group projects and
'                single files from both C and VB.  In VB, a line continuation
'                character of " _" at the end of a line is not counted because
'                it is considered a continuation of the previous line.  Only
'                the first occurance of the continuation is counted.  This is
'                the main module to access Visual Basic and C source
'                code files.  This module will allow the user to select
'                either Visual Basic or C type files and determine the lines
'                of code count.
'
'                Depending of the current standard at the user's location,
'                there are three options to either add to the line count or
'                omit.  Options available are whether or not to include
'                Autogenerated code, blank lines, single braces (C only), or
'                comments in the final total.
'
'                Items NOT counted in VB are TRAILERS.  These are the logical
'                ending statements to a procedural heading.
'
'                   Example:    End Sub      End Function     End Property
'                               End Type     End If           Loop
'                               Wend         Next
'
'                Items NOT counted in C are BRACES( "{" and "}" ) on a line
'                by themselves or with a comment or a semicolon.
'
'                Be sure to make a reference to "Microsoft Script Runtime"
'                file (Scrrun.dll)
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Module created
' 20-JAN-2001  Kenneth Ives  kenaso@tx.rr.com
'              Fixed a bug where if the user had an empty module in their
'              project, erroneous data would be returned.  Now the program
'              will display a message box with the pertinent data and return
'              to the main screen and no output report.
'              Also added an error display routine and centered the form
'              caption.
' ***************************************************************************

Option Explicit

' ***************************************************************************
' Constants
' ***************************************************************************
  Private Const MODULE_NAME     As String = "modLOC"
  Private Const FMT_LINE        As String = "@@@@@@@@@@"
  Private Const RPT_LINE_LENGTH As Long = 78
    
' ***************************************************************************
' Type structures
' ***************************************************************************
  Private Type STATISTICS_COLLECTION
      ModuleName       As String
      TotalLines       As Long
      BlankLines       As Long
      CommentLines     As Long
      AutoGenLines     As Long
      MiscLines        As Long
      SubRoutines      As Long
      FunctionRoutines As Long
      PropertyLet      As Long
      PropertyGet      As Long
      PropertySet      As Long
      Events           As Long
      API_Declares     As Long
      Constants        As Long
      Type_Structures  As Long
      Enum_Structures  As Long
  End Type

' ***************************************************************************
' API Declares
' ***************************************************************************
  ' ZeroMemory function fills a block of memory with zeros.
  Private Declare Sub ZeroMemory Lib "kernel32.dll" Alias "RtlZeroMemory" _
          (Destination As Any, ByVal Length As Long)

  ' The GetTempPath function retrieves the path of the directory designated
  ' for temporary files.  The GetTempPath function gets the temporary file
  ' path as follows:
  '   1.  The path specified by the TMP environment variable.
  '   2.  The path specified by the TEMP environment variable, if TMP
  '       is not defined.
  '   3.  The current directory, if both TMP and TEMP are not defined.
  Private Declare Function GetTempPath Lib "kernel32.dll" _
          Alias "GetTempPathA" (ByVal nBufferLength As Long, _
          ByVal lpBuffer As String) As Long

  ' The GetTempFileName function creates a name for a temporary file.
  ' The filename is the concatenation of specified path and prefix strings,
  ' a hex string formed from a specified integer, and the .TMP extension.
  Private Declare Function GetTempFileName Lib "kernel32.dll" _
          Alias "GetTempFileNameA" (ByVal lpszPath As String, _
          ByVal lpPrefixString As String, ByVal wUnique As Long, _
          ByVal lpTempFileName As String) As Long

' ***************************************************************************
' Module Variables
'                    +-------------- Module level designator
'                    |  +----------- Data type (Collection)
'                    |  |     |----- Variable subname
'                    - --- ---------------
' Naming standard:   m col FileNames
' Variable name:     mcolFileNames
' ***************************************************************************
  Private mcolFileNames         As Collection
  Private mtypSTATS             As STATISTICS_COLLECTION
  Private mlngGrandTotal        As Long
  Private mlngSubTotalLineCount As Long
  Private mblnDSW               As Boolean
  Private mblnDSP               As Boolean
  Private mblnVBG               As Boolean
  Private mblnVBP               As Boolean
  Private mblnUnknown           As Boolean
  Private mblnVisualBasic       As Boolean
  Private mblnPreloadedList     As Boolean
  Private mblnIncludeAutoGen    As Boolean
  Private mblnIncludeComments   As Boolean
  Private mblnIncludeBlankLines As Boolean
  Private mstrRptFile           As String
  Private mstrFileName          As String
  Private mstrWorkingMsg        As String
  Private mstrPathAndFile       As String


' ***************************************************************************
' ****                      Methods                                      ****
' ***************************************************************************

Public Function BeginProcessing(ByVal strPathAndFile As String, _
                                ByVal blnIncludeAutoGen As Boolean, _
                                ByVal blnIncludeBlankLines As Boolean, _
                                ByVal blnIncludeComments As Boolean, _
                                ByVal blnVisualBasic As Boolean, _
                                ByVal blnPreloadedList As Boolean) As String

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
    
    BeginProcessing = vbNullString
    mlngGrandTotal = 0
    
    ' Save passed parameters
    mblnIncludeAutoGen = blnIncludeAutoGen
    mblnIncludeBlankLines = blnIncludeBlankLines
    mblnIncludeComments = blnIncludeComments
    mblnPreloadedList = blnPreloadedList
    mstrPathAndFile = strPathAndFile
    mstrFileName = GetFilename(strPathAndFile)
    
    If mblnPreloadedList Then
        
        mblnVisualBasic = ValidateFileType(strPathAndFile)
        
        ' Unknown file type was selected
        If mblnUnknown Or Len(strPathAndFile) = 0 Then
            Exit Function
        End If
    
    Else
        mblnVisualBasic = blnVisualBasic
    End If
    
    ' Create report file name
    mstrRptFile = Mid$(mstrPathAndFile, 1, _
                  InStrRev(mstrPathAndFile, ".", Len(mstrPathAndFile)) - 1) & _
                  "_LOC.txt"
    
    CreateReport  ' Create report file
    
    ' see which file option was selected
    If mblnVisualBasic Then
    
        ' see if a .VBG project file was selected
        If mblnVBG Then
        
            GetFileList_VBG  ' get list of VBP filenames
    
            DoEvents
            If Not gblnStopProcessing Then
                ProcessFiles_VBP   ' Process list of VBP files
            End If
            
        ElseIf mblnVBP Then
            Process_VBP    ' Process single VBP file
        Else
            Process_Other  ' process other single file
        End If
    
    Else
        ' see if a .VBG project file was selected
        If mblnDSW Then
        
            GetFileList_DSW   ' get list of DSP filenames
    
            DoEvents
            If Not gblnStopProcessing Then
                ProcessFiles_DSP  ' Process list of DSP files
            End If
            
        Else
            ' see if a .DSP or .MAK  project file was selected
            If mblnDSP Then
                Process_DSP    ' Process single Project file
            Else
                Process_Other  ' process other single file
            End If
                  
        End If
    End If
                    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Close        
        mstrRptFile = vbNullString
    End If
    
    BeginProcessing = mstrRptFile   ' Return report file
    EmptyCollection mcolFileNames   ' Empty collection
    
    If Not mblnVisualBasic Then
    
        ' Remove all temp files
        ' this application created
        CleanUpTempFolder
    End If
    
End Function

' ***************************************************************************
' Routine:       ValidateFileType
'
' Description:   This routine will parse the file data string and determine
'                if this is a project or a single file.
'
' Parameters:    strFilename - filename data string to evaluate
'
' Returns:       Boolean flag TRUE = VB component
'                             FALSE = Possible C or C++ component
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 07-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Refined file extension testing
' ***************************************************************************
Public Function ValidateFileType(ByRef strFileName As String) As Boolean

    Dim blnVB        As Boolean
    Dim strExtension As String
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        mblnUnknown = True
        Exit Function
    End If
        
    mblnVBG = False   ' Preset flags to FALSE
    mblnVBP = False
    mblnDSW = False
    mblnDSP = False
    mblnUnknown = False
    
    ' Capture file name extension
    ' and convert to lowercase
    strExtension = LCase$(GetFilenameExt(strFileName))
    
    Select Case strExtension
    
           ' Note VB "mak" files are VB3 and earlier
           Case "vbg", "vbp", "mod", "cls", "frm", "ctl", "dsr"
                blnVB = True
                
           Case "dsw", "dsp", "c", "cpp", "h", "hpp", "mak"
                blnVB = False
           
           ' An unknown file type
           Case Else
                strFileName = vbNullString
                mblnUnknown = True
                GoTo ValidateFileType_CleanUp
    End Select
    
    ' Test file extension
    If blnVB Then
        Select Case strExtension
                                  
               Case "vbg"   ' valid project group file (VBG)
                    mblnVBG = True
                    mblnVBP = True
               
               Case "vbp"   ' valid project file (VBP)
                    mblnVBP = True
                      
               Case "frm", "mod", "cls"
                    ' Fall thru - valid Visual Basic file
                      
               Case Else:  ' Not a valid VB file
                    InfoMsg mstrPathAndFile & vbNewLine & _
                            "is not a valid Visual Basic file"
                    strFileName = vbNullString
        End Select
    Else
        Select Case strExtension
                   
               Case "dsw"   ' valid project file (DSP)
                    mblnDSW = True
                    mblnDSP = True
               
               Case "dsp"   ' valid project file (DSP or MAK)
                    mblnDSP = True
               
               Case "c", "cpp", "h", "hpp"
                    ' Fall thru - valid C or C++ file
                      
               Case Else:  ' Not a valid VB file
                    InfoMsg mstrPathAndFile & vbNewLine & _
                            "is not a valid C or CPP file"
                    strFileName = vbNullString
        End Select
    End If
    
ValidateFileType_CleanUp:
    ValidateFileType = blnVB
  
End Function


' ***************************************************************************
' ****               Internal Procedures and Functions                   ****
' ***************************************************************************

' ***************************************************************************
' Routine:       GetFileList_DSW
'
' Description:   Read the C group project file (DSW) and collect names of
'                subordinate project files (DSP).  Load these file names
'                into a collection to be processed.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Sub GetFileList_DSW()

    Dim hFile        As Long
    Dim lngIndex     As Long
    Dim lngFolderCnt As Long
    Dim lngPosition  As Long
    Dim strPath      As String
    Dim strRecord    As String
    Dim strTmpPath   As String
    Dim strFileName  As String
    
    Const ROUTINE_NAME As String = "GetFileList_DSW"
    
    On Error GoTo GetFileList_DSW_Error
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo GetFileList_DSW_CleanUp
    End If
        
    lngPosition = 0
    strPath = QualifyPath(GetPath(mstrPathAndFile))
    EmptyCollection mcolFileNames
    Set mcolFileNames = New Collection
    
    hFile = FreeFile                           ' Get first free file handle
    Open mstrPathAndFile For Input As #hFile   ' Open VB group project file (.VBG)
    
    ' Loop thru VBG file and collect
    ' all of sub project names
    Do While Not EOF(hFile)
    
        strRecord = vbNullString
        Line Input #hFile, strRecord   ' Read a record
        
        If StrComp(Left$(strRecord, 9), "Project: ", vbTextCompare) = 0 Then
        
            ' Save all data to right of "=" sign
            strFileName = Trim$(ParseData(strRecord, "=", False, True))
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit Do   ' exit Do..Loop
            End If
        
            If Len(strFileName) > 0 Then
            
                If InStr(1, strFileName, " ") > 0 Then
                
                    ' Save only left most portion
                    ' of name from first blank space
                    strFileName = Trim$(ParseData(strFileName, " ", True, True))
                End If
                
                If InStr(1, strFileName, ":") > 0 Then
                    ' This is a fully qualified path and filename
                    
                Else
                    ' Found a period.
                    If Mid$(strFileName, 1, 1) = "." Then
                        
                        lngFolderCnt = CountFolders(strFileName)
                        
                        If lngFolderCnt > 0 Then
                        
                            strTmpPath = UnQualifyPath(strPath)
                            
                            ' Parse backwards thru path and resize accordingly
                            For lngIndex = 1 To lngFolderCnt
                                lngPosition = InStrRev(strTmpPath, "\")
                                strTmpPath = Mid$(strTmpPath, 1, lngPosition - 1)
                            Next lngIndex
                            
                            strFileName = QualifyPath(strTmpPath) & strFileName
                        Else
                            strFileName = strPath & Mid$(strFileName, 3)
                        End If
                    Else
                        If Mid$(strFileName, 1, 1) = "\" Then
                            strFileName = strPath & Mid$(strFileName, 2)
                        Else
                            strFileName = strPath & strFileName
                        End If
                    End If
                End If
                
                ' An error occurred or user opted to STOP processing
                DoEvents
                If gblnStopProcessing Then
                    Exit Do   ' exit Do..Loop
                End If
        
                ' Verify this is a valid file
                If IsPathValid(strFileName) Then
                    mcolFileNames.Add strFileName
                End If
                
            End If
        End If
        
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            Exit Do   ' exit Do..Loop
        End If
        
    ' In VB, the EOF indicator is usually on last line
    Loop
    
    Close #hFile   ' Close VBG file handle
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Close                            ' Close all open files
        EmptyCollection mcolFileNames    ' Empty colection
        GoTo GetFileList_DSW_CleanUp
    End If
        
    ' See if we found any file names
    If mcolFileNames.Count > 0 Then
        SortCollection mcolFileNames     ' Sort file list in ascending order
    Else
        Close                            ' Close all open files
        EmptyCollection mcolFileNames    ' Empty colection
    End If
    
GetFileList_DSW_CleanUp:
    On Error GoTo 0
    Exit Sub

GetFileList_DSW_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close                              ' Close all open files
    EmptyCollection mcolFileNames      ' Empty colection
    gblnStopProcessing = True          ' Set stop processing flag
    Resume GetFileList_DSW_CleanUp
  
End Sub

' ***************************************************************************
' Routine:       GetFileList_VBG
'
' Description:   Read the VB group project file (VBG) and collect the names
'                of the subordinate project files (VBP).  Load these file
'                names into a collection to be processed later.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub GetFileList_VBG()

    Dim hFile        As Long
    Dim lngIndex     As Long
    Dim lngPosition  As Long
    Dim lngFolderCnt As Long
    Dim strPath      As String
    Dim strRecord    As String
    Dim strTmpPath   As String
    Dim strFileName  As String
    Dim strTestData  As String
    
    Const ROUTINE_NAME As String = "GetFileList_VBG"
    
    On Error GoTo GetFileList_VBG_Error
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo GetFileList_VBG_CleanUp
    End If
        
    strPath = QualifyPath(GetPath(mstrPathAndFile))
    EmptyCollection mcolFileNames
    Set mcolFileNames = New Collection
    
    hFile = FreeFile                           ' Get first free file handle
    Open mstrPathAndFile For Input As #hFile   ' Open VB group project file (.VBG)
    
    ' Loop thru VBG file and collect
    ' all of sub project names
    Do While Not EOF(hFile)
    
        strTestData = vbNullString   ' Verify variables are empty
        strRecord = vbNullString
        lngFolderCnt = 0
        
        Line Input #hFile, strRecord   ' Read a record
        
        If Len(Trim$(strRecord)) = 0 Then
            Exit Do   ' No data, time to leave
        End If
        
        ' Not a comment line
        If Left$(strRecord, 1) <> ";" Then
        
            ' Save all data to right of "=" sign
            strFileName = ParseData(strRecord, "=", False, True)
                    
            If Len(strFileName) > 0 Then
            
                ' save data portion prior to "=" sign
                strTestData = LCase$(Left$(strRecord, InStrRev(strRecord, "=") - 1))
                
                ' An error occurred or user opted to STOP processing
                DoEvents
                If gblnStopProcessing Then
                    Exit Do
                End If
        
                ' Evaluate data portion
                Select Case strTestData
                
                       Case "startupproject", "project"
                            'strFilename = VerifyData(strFilename, mstrPathAndFile)
                            If InStr(1, strFileName, ":") > 0 Then
                                ' This is a fully qualified path and filename
                                
                            Else
                                ' Found a period.
                                If Mid$(strFileName, 1, 1) = "." Then
                                                
                                    lngFolderCnt = CountFolders(strFileName)
                                    
                                    If lngFolderCnt > 0 Then
                                    
                                        strTmpPath = UnQualifyPath(strPath)
                                        
                                        ' Parse backwards thru path and resize accordingly
                                        For lngIndex = 1 To lngFolderCnt
                                            lngPosition = InStrRev(strTmpPath, "\")
                                            strTmpPath = Mid$(strTmpPath, 1, lngPosition - 1)
                                        Next lngIndex
                                        
                                        strFileName = QualifyPath(strTmpPath) & strFileName
                                    Else
                                        strFileName = strPath & Mid$(strFileName, 3)
                                    End If
                                Else
                                    If Mid$(strFileName, 1, 1) = "\" Then
                                        strFileName = strPath & Mid$(strFileName, 2)
                                    Else
                                        strFileName = strPath & strFileName
                                    End If
                                End If
                            End If
                            
                            ' An error occurred or user opted to STOP processing
                            DoEvents
                            If gblnStopProcessing Then
                                Exit Do
                            End If
        
                            ' Verify this is a valid file
                            If IsPathValid(strFileName) Then
                                mcolFileNames.Add strFileName
                            End If
                    
                       Case Else   ' Not recognized
                            strFileName = vbNullString
                End Select
                
            End If
        End If
        
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            Exit Do   ' exit Do..Loop
        End If
        
    Loop   ' In VB, the EOF indicator is usually on last line
    
    Close #hFile   ' Close VBG file handle
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Close                            ' Close all open files
        EmptyCollection mcolFileNames    ' Empty colection
        GoTo GetFileList_VBG_CleanUp
    End If
        
    ' See if we found any file names
    If mcolFileNames.Count > 0 Then
        SortCollection mcolFileNames     ' Sort file list in ascending order
    Else
        Close                            ' Close all open files
        EmptyCollection mcolFileNames    ' Empty colection
    End If
    
GetFileList_VBG_CleanUp:
    On Error GoTo 0
    Exit Sub

GetFileList_VBG_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close                              ' Close all open files
    EmptyCollection mcolFileNames      ' Empty colection
    gblnStopProcessing = True          ' Set stop processing flag
    Resume GetFileList_VBG_CleanUp
  
End Sub

' ***************************************************************************
' Routine:       ProcessFiles_DSP
'
' Description:   This routine will read the collection of VBP files and
'                process them as part of a VB project group.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub ProcessFiles_DSP()

    ' Called by BeginProcessing()
    
    Dim hFile         As Long
    Dim lngIndex      As Long
    Dim lngProjectCnt As Long
    Dim strFileName   As String
    
    Const ROUTINE_NAME As String = "ProcessFiles_DSP"
    
    On Error GoTo ProcessFiles_DSP_Error
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo ProcessFiles_DSP_CleanUp
    End If
        
    lngProjectCnt = mcolFileNames.Count  ' Get number of files to process
    
    If lngProjectCnt > 0 Then
    
        ' Prepare report file
        hFile = FreeFile                       ' Get first free file handle
        Open mstrRptFile For Append As #hFile  ' Append data to report
        Print #hFile, "   DSW Name:  " & ShrinkToFit(mstrPathAndFile, 60) & vbNewLine
        Close #hFile                           ' Close report file
    
        ' Start reading the filelist array
        For lngIndex = 1 To lngProjectCnt
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit For    ' exit For..Next loop
            End If
            
            mstrPathAndFile = mcolFileNames.Item(lngIndex)  ' Save VBP path and filename
                   
            ' Write name of VBP file
            hFile = FreeFile                       ' Get first free file handle
            Open mstrRptFile For Append As #hFile  ' Append data to report
            Print #hFile, "   DSP Name:  " & ShrinkToFit(mstrPathAndFile, 60) & vbNewLine
            Close #hFile                           ' Close report file
                        
            Process_DSP_File   ' Process DSP file
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit For    ' exit For..Next loop
            End If
            
            hFile = FreeFile                       ' Get first free file handle
            Open mstrRptFile For Append As #hFile  ' Append data to report
            Print #hFile, Space$(10) & String$(10, "-")
            Print #hFile, Space$(10) & _
                          Format(Format(mlngSubTotalLineCount, "#,0"), FMT_LINE) & _
                          "  Sub-total for project " & vbNewLine & Space$(22) & _
                          ShrinkToFit(strFileName, 60)
            Print #hFile, " "
            Close #hFile    ' Close report file
            
        Next lngIndex
      
    End If
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Close                          ' Close all open files
        GoTo ProcessFiles_DSP_CleanUp
    End If
            
    AppendReport                       ' Append closing to end of report
  
ProcessFiles_DSP_CleanUp:
    EmptyCollection mcolFileNames      ' Empty collection
    On Error GoTo 0
    Exit Sub

ProcessFiles_DSP_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close                              ' Close all open files
    EmptyCollection mcolFileNames      ' Empty collection
    gblnStopProcessing = True          ' Set processing flag to FALSE
    Resume ProcessFiles_DSP_CleanUp
  
End Sub

' ***************************************************************************
' Routine:       ProcessFiles_VBP
'
' Description:   This routine will read the collection of VBP files and
'                process them as part of a VB project group.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub ProcessFiles_VBP()

    ' Called by BeginProcessing()
    
    Dim hFile         As Long
    Dim lngIndex      As Long
    Dim lngProjectCnt As Long
    Dim strFileName   As String
    
    Const ROUTINE_NAME As String = "ProcessFiles_VBP"
    
    On Error GoTo ProcessFiles_VBP_Error
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo ProcessFiles_VBP_CleanUp
    End If
        
    lngProjectCnt = mcolFileNames.Count  ' Get number of files to process
    
    If lngProjectCnt > 0 Then
    
        ' Prepare report file
        hFile = FreeFile                       ' Get first free file handle
        Open mstrRptFile For Append As #hFile  ' Append data to report
        Print #hFile, "   VBG Name:  " & ShrinkToFit(mstrPathAndFile, 60) & vbNewLine
        Close #hFile                           ' Close report file
    
        ' Start reading the filelist array
        For lngIndex = 1 To lngProjectCnt
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit For    ' exit For..Next loop
            End If
            
            mstrPathAndFile = mcolFileNames.Item(lngIndex)  ' Save VBP path and filename
                   
            ' Write name of VBP file
            hFile = FreeFile                       ' Get first free file handle
            Open mstrRptFile For Append As #hFile  ' Append data to report
            Print #hFile, "   VBP Name:  " & ShrinkToFit(mstrPathAndFile, 60) & vbNewLine
            Close #hFile                           ' Close report file
                        
            Process_VBP_File   ' Process VBP file
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit For    ' exit For..Next loop
            End If
            
            hFile = FreeFile                       ' Get first free file handle
            Open mstrRptFile For Append As #hFile  ' Append data to report
            Print #hFile, Space$(10) & String$(10, "-")
            Print #hFile, Space$(10) & _
                          Format(Format(mlngSubTotalLineCount, "#,0"), FMT_LINE) & _
                          "  Sub-total for project " & vbNewLine & Space$(22) & _
                          ShrinkToFit(strFileName, 60)
            Print #hFile, " "
            Close #hFile                           ' Close report file
            
        Next lngIndex
    
    End If
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Close                          ' Close all open files
        GoTo ProcessFiles_VBP_CleanUp
    End If
            
    AppendReport                       ' Append closing to end of report

ProcessFiles_VBP_CleanUp:
    EmptyCollection mcolFileNames      ' Empty collection
    On Error GoTo 0
    Exit Sub

ProcessFiles_VBP_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close                              ' Close all open files
    EmptyCollection mcolFileNames      ' Empty collection
    gblnStopProcessing = True          ' Set processing flag to FALSE
    Resume ProcessFiles_VBP_CleanUp
  
End Sub

' ***************************************************************************
' Routine:       Process_DSP
'
' Description:   The C source code file is sent to this module so a header
'                may be written to the output file.  Then another routine is
'                called to tally the data.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub Process_DSP()

    ' Called by BeginProcessing()
    
    Dim hFile As Long
    
    Const ROUTINE_NAME As String = "Process_DSP"
    
    On Error GoTo Process_DSP_Error
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Process_DSP_CleanUp
    End If
        
    ' Update output file
    hFile = FreeFile
    Open mstrRptFile For Append As #hFile
    Print #hFile, "   DSP Name:  " & ShrinkToFit(mstrPathAndFile, 60) & vbNewLine
    Close #hFile
    
    Process_DSP_File   ' Collect file statistics
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Process_DSP_CleanUp
    End If
        
    AppendReport   ' Append to end of report

Process_DSP_CleanUp:
    On Error GoTo 0
    Exit Sub

Process_DSP_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close        
    gblnStopProcessing = True
    Resume Process_DSP_CleanUp

End Sub

' ***************************************************************************
' Routine:       Process_VBP
'
' Description:   The VB source code file is sent to this module so a header
'                may be written to the output file.  Then another routine is
'                called to tally the data.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub Process_VBP()

    ' Called by BeginProcessing()
    
    Dim hFile As Long
    
    Const ROUTINE_NAME As String = "Process_VBP"
    
    On Error GoTo Process_VBP_Error

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Process_VBP_CleanUp
    End If
        
    ' Prepare the output file
    hFile = FreeFile
    Open mstrRptFile For Append As #hFile
    Print #hFile, "   VBP Name:  " & ShrinkToFit(mstrPathAndFile, 60) & vbNewLine
    Close #hFile
    
    ' Collect file statistics
    Process_VBP_File
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Process_VBP_CleanUp
    End If
        
    AppendReport   ' Append to end of report

Process_VBP_CleanUp:
    On Error GoTo 0
    Exit Sub

Process_VBP_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close        
    gblnStopProcessing = True
    Resume Process_VBP_CleanUp
  
End Sub

' ***************************************************************************
' Routine:       Process_DSP_File
'
' Description:   The C source code file is sent to this module so a header
'                may be written to the output file.  Then another routine is
'                called to tally the data.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub Process_DSP_File()

    ' Called by Process_DSP()
    '           ProcessFiles_DSP()
    
    Dim hFile        As Long
    Dim lngMax       As Long
    Dim lngIndex     As Long
    Dim lngPosition  As Long
    Dim lngFolderCnt As Long
    Dim strPath      As String
    Dim strRecord    As String
    Dim strTmpPath   As String
    Dim strTestExt   As String
    Dim strTestData  As String
    Dim strFileName  As String
    Dim colModules   As Collection
    
    Const ROUTINE_NAME As String = "Process_DSP_File"
    
    On Error GoTo Process_DSP_File_Error

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Process_DSP_File_CleanUp
    End If
        
    frmMain.lblFilename.Caption = ShrinkToFit(mstrPathAndFile, 50)
    mlngSubTotalLineCount = 0
    EmptyCollection colModules
    Set colModules = New Collection
      
    strPath = QualifyPath(GetPath(mstrPathAndFile))
    
    hFile = FreeFile   ' get first free file handle
    Open mstrPathAndFile For Input As #hFile
    
    Do
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            Exit Do   ' exit Do..Loop
        End If
        
        Line Input #hFile, strRecord
        
        strRecord = CleanUpData(strRecord)
        
        If Left$(strRecord, 1) = "#" Or _
           Len(strRecord) = 0 Then
           
            GoTo BottomOfLoop
        End If
        
        ' We are looking for these type of lines
        '       SOURCE=.\main.c
        '       SOURCE="..\CertificatePage.cpp"
        '       SOURCE=..\..\contrib\masmx86\gvmat32c.c
        strTestData = LCase$(Left$(strRecord, 6))
        
        If StrComp(strTestData, "source", vbTextCompare) = 0 Then
                
            ' Save everything to the right of the equal sign
            strFileName = Trim$(ParseData(strRecord, "=", False, True))
            strTestExt = GetFilenameExt(strFileName)
            strTestExt = LCase$(strTestExt)
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit Do   ' exit Do..Loop
            End If
        
            Select Case strTestExt
                   ' standard C type files
                   Case "c", "cpp", "h", "hpp":
                        
                        If InStr(1, strFileName, ":") > 0 Then
                            ' This is a fully qualified path and filename
                            
                        Else
                            ' Found a period.
                            If Mid$(strFileName, 1, 1) = "." Then
                                
                                lngFolderCnt = CountFolders(strFileName)
                                
                                If lngFolderCnt > 0 Then
                                
                                    strTmpPath = UnQualifyPath(strPath)
                                    
                                    ' Parse backwards thru path and resize accordingly
                                    For lngIndex = 1 To lngFolderCnt
                                        lngPosition = InStrRev(strTmpPath, "\")
                                        strTmpPath = Mid$(strTmpPath, 1, lngPosition - 1)
                                    Next lngIndex
                                    
                                    strFileName = QualifyPath(strTmpPath) & strFileName
                                Else
                                    strFileName = strPath & Mid$(strFileName, 3)
                                End If
                            Else
                                If Mid$(strFileName, 1, 1) = "\" Then
                                    strFileName = strPath & Mid$(strFileName, 2)
                                Else
                                    strFileName = strPath & strFileName
                                End If
                            End If
                        End If
                        
                        ' An error occurred or user opted to STOP processing
                        DoEvents
                        If gblnStopProcessing Then
                            Exit Do   ' exit Do..Loop
                        End If
        
                        ' Verify this is a valid file
                        If IsPathValid(strFileName) Then
                            colModules.Add strFileName
                        End If
                        
                   Case Else: ' fall thru and read next record
            
            End Select
        End If
        
BottomOfLoop:
    
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            Exit Do   ' exit Do..Loop
        End If
        
    Loop While Not EOF(hFile)
  
    ' close file we have just read
    Close #hFile
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Close        
        GoTo Process_DSP_File_CleanUp
    End If
        
    ' Sort the files in ascending order
    lngMax = colModules.Count
    
    If lngMax > 0 Then
    
        SortCollection colModules
        
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            Close        
            GoTo Process_DSP_File_CleanUp
        End If
        
        ' process each module within the array
        For lngIndex = 1 To lngMax
             
            ZeroMemory mtypSTATS, Len(mtypSTATS)               ' Empty statistics counter structure
            mtypSTATS.ModuleName = colModules.Item(lngIndex)   ' Save path\name of next C file
            Read_C_File colModules.Item(lngIndex)              ' Process C file
            mlngSubTotalLineCount = mlngSubTotalLineCount + mtypSTATS.TotalLines   ' Update stats
                                      
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit For
            End If
        
        Next lngIndex
    
    End If
    
Process_DSP_File_CleanUp:
    EmptyCollection colModules
    On Error GoTo 0
    Exit Sub

Process_DSP_File_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close        
    gblnStopProcessing = True
    Resume Process_DSP_File_CleanUp
    
End Sub

' ***************************************************************************
' Routine:       Process_VBP_File
'
' Description:   The VB source code file is sent to this module so a header
'                may be written to the output file.  Then another routine is
'                called to tally the data.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub Process_VBP_File()

    ' Called by Process_VBP()
    '           ProcessFiles_VBP()
    
    Dim hFile        As Long
    Dim lngFolderCnt As Long
    Dim lngIndex     As Long
    Dim lngColCount  As Long
    Dim lngPosition  As Long
    Dim strPath      As String
    Dim strTmpPath   As String
    Dim strRecord    As String
    Dim strTestData  As String
    Dim strFileName  As String
    Dim colModules   As Collection
    
    Const ROUTINE_NAME As String = "Process_VBP_File"
    
    On Error GoTo Process_VBP_File_Error
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Process_VBP_File_CleanUp
    End If
        
    frmMain.lblFilename.Caption = ShrinkToFit(mstrPathAndFile, 50)
    mlngSubTotalLineCount = 0
    EmptyCollection colModules
    Set colModules = New Collection
    
    strPath = GetPath(mstrPathAndFile)
    strPath = QualifyPath(strPath)
    
    ' open the file and process the data
    hFile = FreeFile  ' get first free file handle
    Open mstrPathAndFile For Input As #hFile
    
    Do
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            Exit Do   ' exit Do..Loop
        End If
        
        Line Input #hFile, strRecord
        strRecord = CleanUpData(strRecord)
        
        If EOF(hFile) Or Len(strRecord) = 0 Then
            Exit Do   ' exit Do..Loop
        End If
    
        ' We are looking for these types of lines
        '       Form=frmCrypt.frm
        '       Module=modCrypt; modCrypt.bas
        '       Class=clsCryptINI; ..\..\..\VB_Code\Class\clsCryptINI.cls
        lngPosition = InStr(1, strRecord, "=")
    
        If lngPosition = 0 Then
            Exit Do   ' exit Do..Loop
        Else
            ' save the portion prior to the equal sign
            strTestData = LCase$(Left$(strRecord, lngPosition - 1))
            strTmpPath = vbNullString
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit Do   ' exit Do..Loop
            End If
        
            ' evaluate that portion
            Select Case strTestData
                        
                   Case "form", "designer", "usercontrol"   ' frm, dsr, ctl
                        ' capture everything to the right of the equal sign
                        strFileName = Trim$(ParseData(strRecord, "=", False, True))
                            
                        If InStr(1, strFileName, ":") > 0 Then
                            ' This is a fully qualified path and filename
                        Else
                            ' Found a period.
                            If Mid$(strFileName, 1, 1) = "." Then
                                
                                lngFolderCnt = CountFolders(strFileName)
                                
                                If lngFolderCnt > 0 Then
                                
                                    strTmpPath = UnQualifyPath(strPath)
                                    
                                    ' Parse backwards thru path and resize accordingly
                                    For lngIndex = 1 To lngFolderCnt
                                        lngPosition = InStrRev(strTmpPath, "\")
                                        strTmpPath = Mid$(strTmpPath, 1, lngPosition - 1)
                                    Next lngIndex
                                    
                                    strFileName = QualifyPath(strTmpPath) & strFileName
                                Else
                                    strFileName = strPath & Mid$(strFileName, 3)
                                End If
                            Else
                                If Mid$(strFileName, 1, 1) = "\" Then
                                    strFileName = strPath & Mid$(strFileName, 2)
                                Else
                                    strFileName = strPath & strFileName
                                End If
                            End If
                        End If
                        
                        ' An error occurred or user opted to STOP processing
                        DoEvents
                        If gblnStopProcessing Then
                            Exit Do   ' exit Do..Loop
                        End If
        
                        If IsPathValid(strFileName) Then
                            colModules.Add strFileName
                        End If
                                                                     
                   Case "class", "module"   ' cls, bas
                        ' capture everything to the right of the semicolon
                        strFileName = Trim$(ParseData(strRecord, ";", False, False))
                            
                        If InStr(1, strFileName, ":") > 0 Then
                            ' This is a fully qualified path and filename
                            
                        Else
                            ' Found a period.
                            If Mid$(strFileName, 1, 1) = "." Then
                                
                                lngFolderCnt = CountFolders(strFileName)
                                
                                If lngFolderCnt > 0 Then
                                
                                    strTmpPath = UnQualifyPath(strPath)
                                    
                                    ' Parse backwards thru path and resize accordingly
                                    For lngIndex = 1 To lngFolderCnt
                                        lngPosition = InStrRev(strTmpPath, "\")
                                        strTmpPath = Mid$(strTmpPath, 1, lngPosition - 1)
                                    Next lngIndex
                                    
                                    strFileName = QualifyPath(strTmpPath) & strFileName
                                Else
                                    strFileName = strPath & Mid$(strFileName, 3)
                                End If
                            Else
                                If Mid$(strFileName, 1, 1) = "\" Then
                                    strFileName = strPath & Mid$(strFileName, 2)
                                Else
                                    strFileName = strPath & strFileName
                                End If
                            End If
                        End If
                        
                        ' An error occurred or user opted to STOP processing
                        DoEvents
                        If gblnStopProcessing Then
                            Exit Do   ' exit Do..Loop
                        End If
        
                        ' Verify this is a valid file
                        If IsPathValid(strFileName) Then
                            colModules.Add strFileName
                        End If
                        
                   Case Else: ' fall thru and read next record
            End Select
        End If
    
    Loop While Not EOF(hFile)
    
    ' close file we have just read
    Close #hFile
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Process_VBP_File_CleanUp
    End If
        
    ' Sort the files in ascending order
    lngColCount = colModules.Count
    
    If lngColCount > 0 Then
        
        SortCollection colModules
        
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            GoTo Process_VBP_File_CleanUp
        End If
        
        ' process each module within the array
        For lngIndex = 1 To lngColCount
        
            ZeroMemory mtypSTATS, Len(mtypSTATS)               ' Empty statistics counter structure
            mtypSTATS.ModuleName = colModules.Item(lngIndex)   ' Save path\name of next VBP file
            Read_VB_File colModules.Item(lngIndex)             ' Process VBP file
            
            mlngSubTotalLineCount = mlngSubTotalLineCount + mtypSTATS.TotalLines   ' Update stats
                                 
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit For
            End If
        
        Next lngIndex
        
    End If
    
Process_VBP_File_CleanUp:
    EmptyCollection colModules
    On Error GoTo 0
    Exit Sub

Process_VBP_File_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close        
    gblnStopProcessing = True
    Resume Process_VBP_File_CleanUp
    
End Sub

' ***************************************************************************
' Routine:       Read_C_File
'
' Description:   A file is sequentially read and the various lines are
'                totaled.  The final tallies are written to another file.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub Read_C_File(ByVal strPathAndFile As String)

    Dim hFile           As Long
    Dim blnCommentBlock As Boolean
    Dim strMsg1         As String
    Dim strMsg2         As String
    Dim strRecord       As String
    Dim objFSO          As FileSystemObject
    
    Const ROUTINE_NAME As String = "Read_C_File"
    
    On Error GoTo Read_C_File_Error
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Read_C_File_CleanUp
    End If
        
    blnCommentBlock = False
    strMsg1 = "  Blank lines"
    strMsg2 = "  Comment lines"
    
    mtypSTATS.ModuleName = strPathAndFile
    mstrWorkingMsg = ShrinkToFit(strPathAndFile, 55)
    frmMain.UpdateFileDisplay mstrWorkingMsg
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Read_C_File_CleanUp
    End If
    
    ' Create temp C file to work with
    strPathAndFile = CreateTempFile(strPathAndFile)
    
    ' open file and start processing
    hFile = FreeFile
    Open strPathAndFile For Input As #hFile
    
    ' Loop thru the file until we get to the end of the autogenerated code
    With mtypSTATS
        Do
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit Do   ' exit Do..Loop
            End If
            
            ' read a record
            strRecord = vbNullString
            Line Input #hFile, strRecord
            
            ' remove any leading and trailing spaces
            strRecord = CleanUpData(strRecord)
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit Do   ' exit Do..Loop
            End If
            
            ' see if we are in a comment block
            If blnCommentBlock Then
                ' look for end of comment block
                If InStr(1, strRecord, "*/") > 0 Then
                    blnCommentBlock = False
                End If
                
                .CommentLines = .CommentLines + 1
                GoTo BottomOfLoop
            End If
            
            ' Look for blank lines
            If Len(strRecord) = 0 Then
                .BlankLines = .BlankLines + 1
                
            ' see if we found a block of comments
            ElseIf Left$(strRecord, 2) = "/*" Then
                .CommentLines = .CommentLines + 1
                
                If InStr(1, strRecord, "*/") > 0 Then
                    blnCommentBlock = False    ' found on same line
                Else
                    blnCommentBlock = True     ' end of block not found
                End If
        
            ' Look for comment lines
            ElseIf Left$(strRecord, 2) = "//" Then
                .CommentLines = .CommentLines + 1
            
            ' Look for braces as the first character.  We do not count
            ' them if they are on a line by themselves.
            ElseIf (Len(strRecord) = 1 And _
                   (Left$(strRecord, 1) = "{" Or Left$(strRecord, 1) = "}")) Then
                   ' Fall thru and do nothing
            Else
                ' An error occurred or user opted to STOP processing
                DoEvents
                If gblnStopProcessing Then
                    Exit Do   ' exit Do..Loop
                End If
            
                ' increment the miscellaneous line count
                .MiscLines = .MiscLines + 1
            End If
            
BottomOfLoop:
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit Do   ' exit Do..Loop
            End If
            
        Loop While Not EOF(hFile)
    End With
    
    Close #hFile
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Read_C_File_CleanUp
    End If
        
    ' Get the totals
    With mtypSTATS
        If mblnIncludeBlankLines Then
            .TotalLines = .TotalLines + .BlankLines
        Else
            strMsg1 = strMsg1 & " (** Not included in totals **)"
        End If
        
        If mblnIncludeComments Then
            .TotalLines = .TotalLines + .CommentLines
        Else
            strMsg2 = strMsg2 & " (** Not included in totals **)"
        End If
        
        .TotalLines = .TotalLines + .MiscLines
        mlngGrandTotal = mlngGrandTotal + .TotalLines
    End With
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Read_C_File_CleanUp
    End If
        
    ' Append data to the output file
    hFile = FreeFile
    Open mstrRptFile For Append As #hFile
        
    Print #hFile, "Module Name:  " & mtypSTATS.ModuleName
    Print #hFile, " "
    Print #hFile, Space$(10) & Format(Format(mtypSTATS.BlankLines, "#,0"), FMT_LINE) & strMsg1
    Print #hFile, Space$(10) & Format(Format(mtypSTATS.CommentLines, "#,0"), FMT_LINE) & strMsg2
    Print #hFile, Space$(10) & Format(Format(mtypSTATS.MiscLines, "#,0"), FMT_LINE) & "  Miscellaneous lines of code"
    Print #hFile, Space$(10) & String$(10, "-")
    Print #hFile, Space$(10) & Format(Format(mtypSTATS.TotalLines, "#,0"), FMT_LINE) & "  Total number of lines of code"
    Print #hFile, " "
    Print #hFile, " "
    Close #hFile
    
Read_C_File_CleanUp:
    On Error Resume Next
    Set objFSO = New FileSystemObject
    objFSO.DeleteFile strPathAndFile
    Set objFSO = Nothing
    On Error GoTo 0
    
    Exit Sub
  
Read_C_File_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close        
    gblnStopProcessing = True
    Resume Read_C_File_CleanUp
    
End Sub

' ***************************************************************************
' Routine:       Read_VB_File
'
' Description:   A file is sequentially read and the various lines are
'                totaled.  The final tallies are written to another file.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub Read_VB_File(ByVal strPathAndFile As String)

    Dim hFile            As Long
    Dim lngBlanks        As Long
    Dim blnCancel        As Boolean
    Dim blnAutoGen       As Boolean
    Dim blnConstant      As Boolean
    Dim blnTypeStruct    As Boolean
    Dim blnSubRoutine    As Boolean
    Dim blnAPIDeclare    As Boolean
    Dim blnCommentLine   As Boolean
    Dim blnFuncRoutine   As Boolean
    Dim blnLineContinued As Boolean
    Dim strMsg0          As String
    Dim strMsg1          As String
    Dim strMsg2          As String
    Dim strRecord        As String
    
    Const ROUTINE_NAME As String = "Read_VB_File"
    
    On Error GoTo Read_VB_File_Error
  
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Read_VB_File_CleanUp
    End If
        
    blnCancel = False
    blnAutoGen = False
    blnConstant = False
    blnTypeStruct = False
    blnAPIDeclare = False
    blnSubRoutine = False
    blnCommentLine = False
    blnFuncRoutine = False
    blnLineContinued = False
    
    lngBlanks = 0
    strMsg0 = "  Auto generated lines"
    strMsg1 = "  Blank lines"
    strMsg2 = "  Comment lines"
    
    mtypSTATS.ModuleName = strPathAndFile
    mstrWorkingMsg = ShrinkToFit(strPathAndFile, 55)
    frmMain.UpdateFileDisplay mstrWorkingMsg
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Read_VB_File_CleanUp
    End If
        
    ' open the file and start processing
    hFile = FreeFile
    Open strPathAndFile For Input As #hFile
    
    ' Loop thru the file until we get to the end of the autogenerated code
    With mtypSTATS
        Do
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit Do   ' exit Do..Loop
            End If
            
            ' read a record
            Line Input #hFile, strRecord
            
            ' remove any leading and trailing spaces
            strRecord = CleanUpData(strRecord)
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit Do   ' exit Do..Loop
            End If
            
            ' See if we have processed the auto generated data
            If Not blnAutoGen Then
                
                ' process the data
                blnAutoGen = True
                .AutoGenLines = AutoGen_Code(hFile, strRecord, lngBlanks, blnCancel)
                .BlankLines = .BlankLines + lngBlanks
                    
                If EOF(hFile) Then
                    Exit Do   ' exit Do..Loop
                End If
                
            End If
            
            ' An error occurred or user opted to STOP processing
            DoEvents
            If gblnStopProcessing Then
                Exit Do   ' exit Do..Loop
            End If
            
            ' see if this a continuation of the previous line
            If blnLineContinued Then
                If Right$(strRecord, 2) = " _" Then
                    GoTo BottomOfLoop  ' read another record
                Else
                    blnLineContinued = False
                    GoTo BottomOfLoop  ' read another record
                End If
            End If
                
            ' Evaluate the type of data
            If Len(strRecord) = 0 Then
                .BlankLines = .BlankLines + 1
                
            ' Look for trailers (End Sub, End If, Loop, Wend, etc.)
            ' These are not counted since they are an integral part
            ' of a heading
            ElseIf Trailer(strRecord) Then

                GoTo BottomOfLoop      ' read another record
            
            ' Look for comment lines, both hidden and visible
            ElseIf Comments(strRecord, blnLineContinued) Then
                .CommentLines = .CommentLines + 1
            
            ' look for a Sub routine
            ElseIf SubRoutine(strRecord, blnLineContinued) Then
                .SubRoutines = .SubRoutines + 1

            ' Look for a Function routine
            ElseIf FunctionRoutine(strRecord, blnLineContinued) Then
                .FunctionRoutines = .FunctionRoutines + 1
            
            ' Look for a Property Let routine
            ElseIf PropertyLet(strRecord, blnLineContinued) Then
                .PropertyLet = .PropertyLet + 1
            
            ' Look for a Property Get routine
            ElseIf PropertyGet(strRecord, blnLineContinued) Then
                .PropertyGet = .PropertyGet + 1
            
            ' Look for a Property Set routine
            ElseIf PropertySet(strRecord, blnLineContinued) Then
                .PropertySet = .PropertySet + 1
            
            ' Look for an Event routine
            ElseIf Events(strRecord, blnLineContinued) Then
                .Events = .Events + 1
            
            ' Look for API Declaes
            ElseIf API_Declare(strRecord, blnLineContinued) Then
                .API_Declares = .API_Declares + 1
            
            ' Look for Constants
            ElseIf ConstantVar(strRecord, blnLineContinued) Then
                .Constants = .Constants + 1
            
            ' Look for Type Structures
            ElseIf Type_Structure(strRecord, blnLineContinued) Then
                .Type_Structures = .Type_Structures + 1
                
            ' Look for Enum Structures
            ElseIf Enum_Structure(strRecord, blnLineContinued) Then
                .Enum_Structures = .Enum_Structures + 1
                  
            ' increment miscellaneous counter
            Else
                ' An error occurred or user opted to STOP processing
                DoEvents
                If gblnStopProcessing Then
                    Exit Do   ' exit Do..Loop
                End If
            
                .MiscLines = .MiscLines + 1
                If Right$(strRecord, 2) = " _" Then
                    blnLineContinued = True
                End If
            End If
        
BottomOfLoop:
            
        Loop While Not EOF(hFile)
    End With
    
    Close #hFile
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Read_VB_File_CleanUp
    End If
        
    With mtypSTATS
        ' Capture totals
        If mblnIncludeAutoGen Then
            .TotalLines = .TotalLines + .AutoGenLines
        Else
            strMsg0 = strMsg0 & " (** Not included in totals **)"
        End If
        
        If mblnIncludeBlankLines Then
            .TotalLines = .TotalLines + .BlankLines
        Else
            strMsg1 = strMsg1 & " (** Not included in totals **)"
        End If
        
        If mblnIncludeComments Then
            .TotalLines = .TotalLines + .CommentLines
        Else
            strMsg2 = strMsg2 & " (** Not included in totals **)"
        End If
        
        .TotalLines = .TotalLines + .MiscLines + .API_Declares + _
                      .Constants + .FunctionRoutines + .SubRoutines + _
                      .Type_Structures + .Enum_Structures + .Events
                             
        mlngGrandTotal = mlngGrandTotal + .TotalLines
    End With
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Read_VB_File_CleanUp
    End If
        
    ' Append data to the output file
    hFile = FreeFile
    Open mstrRptFile For Append As #hFile
        
    With mtypSTATS
        If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
        Print #hFile, "Module Name:  " & .ModuleName & vbNewLine
        
        ' Only display a total if quantity is greater than zero
        If .Constants > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.Constants, "#,0"), FMT_LINE) & "  Constant variables"
        End If
            
        If .Enum_Structures > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.Enum_Structures, "#,0"), FMT_LINE) & "  Enum Structures"
        End If
            
        If .Type_Structures > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.Type_Structures, "#,0"), FMT_LINE) & "  Type Structures"
        End If
            
        If .API_Declares > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.API_Declares, "#,0"), FMT_LINE) & "  API Declare statements"
        End If
        
        If .PropertyLet > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.PropertyLet, "#,0"), FMT_LINE) & "  Property Let routines"
        End If
            
        If .PropertyGet > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.PropertyGet, "#,0"), FMT_LINE) & "  Property Get routines"
        End If
        
        If .PropertySet > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.PropertySet, "#,0"), FMT_LINE) & "  Property Set routines"
        End If
        
        If .Events > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.Events, "#,0"), FMT_LINE) & "  Event routines"
        End If
        
        If .SubRoutines > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.SubRoutines, "#,0"), FMT_LINE) & "  Sub routines"
        End If
        
        If .FunctionRoutines > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.FunctionRoutines, "#,0"), FMT_LINE) & "  Functions"
        End If
        
        If .MiscLines > 0 Then
            If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
            Print #hFile, Space$(10) & Format(Format(.MiscLines, "#,0"), FMT_LINE) & "  Miscellaneous lines of code"
        End If
        
        If gblnStopProcessing Then GoTo Read_VB_File_CleanUp
        Print #hFile, Space$(10) & Format(Format(.AutoGenLines, "#,0"), FMT_LINE) & strMsg0
        Print #hFile, Space$(10) & Format(Format(.BlankLines, "#,0"), FMT_LINE) & strMsg1
        Print #hFile, Space$(10) & Format(Format(.CommentLines, "#,0"), FMT_LINE) & strMsg2
        Print #hFile, Space$(10) & String$(10, "-")
        Print #hFile, Space$(10) & Format(Format(.TotalLines, "#,0"), FMT_LINE) & "  Module lines of code"
        Print #hFile, ""
    End With
        
Read_VB_File_CleanUp:
    Close #hFile
    On Error GoTo 0
    Exit Sub
  
Read_VB_File_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close        
    gblnStopProcessing = True
  
End Sub

' ***************************************************************************
' Routine:       Process_Other
'
' Description:   The source code file is sent to this module so a header
'                may be written to the output file.  Then another routine is
'                called to tally the data.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Sub Process_Other()

    ' Called by BeginProcessing()
    
    Dim strPathAndFile As String

    Const ROUTINE_NAME As String = "Process_Other"
    
    On Error GoTo Process_Other_Error
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Process_Other_CleanUp
    End If
        
    strPathAndFile = mstrPathAndFile
    
    If mblnVisualBasic Then
        Read_VB_File strPathAndFile
    Else
        Read_C_File strPathAndFile
    End If
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo Process_Other_CleanUp
    End If
        
    AppendReport   ' Append to end of report
    
Process_Other_CleanUp:
    On Error GoTo 0
    Exit Sub

Process_Other_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close        
    gblnStopProcessing = True
    Resume Process_Other_CleanUp
  
End Sub

' ***************************************************************************
' Routine:       AutoGen_Code
'
' Description:   Counts the number of auto generated lines of code at the
'                beginning of the VB file.
'
' Parameters:    hFile - File handle of the currently open file
'                strRecord - Current record that is in the buffer
'                lngBlanks - Counter for the number of blank lines
'                       encountered
'                blnCancel = if an earlier version of VB shows up, the user
'                       can cancel processing
'
' Returns:       Number of autogenerated data lines
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Function AutoGen_Code(ByVal hFile As Integer, _
                              ByRef strRecord As String, _
                              ByRef lngBlanks As Long, _
                              ByRef blnCancel As Boolean) As Long

    Dim intResp               As Integer
    Dim lngCount              As Long
    Dim strTemp               As String
    Dim blnFound1stOccurance  As Boolean
    
    Const VB_ATTRIB As String = "Attribute "
    
    lngCount = 0
    lngBlanks = 0
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the first record
    If StrComp(Left$(strRecord, 10), "version 2.", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 10), "version 3.", vbTextCompare) = 0 Then
           intResp = ResponseMsg("Cannot accurately process project created " & _
                                 vbNewLine & " with Visual Basic 3.0 or below", _
                                 vbInformation Or vbOKCancel)
           
           If intResp = vbCancel Then
               blnCancel = True
           End If
           
           GoTo Normal_Exit
           
    ' begins with single quote or blank line
    ' then leave
    ElseIf Left$(strRecord, 1) = "'" Or _
           Len(strRecord) = 0 Then
           
        GoTo Normal_Exit
        
    ElseIf Len(strRecord) > 0 Then
        lngCount = 1  ' Assume Auto generated data
    End If
    
    ' See if the first line begins with "Attribute "
    strTemp = Left$(strRecord, 10)
    If StrComp(strTemp, VB_ATTRIB, vbTextCompare) = 0 Then
        ' we found the first occurance
        blnFound1stOccurance = True
    Else
        blnFound1stOccurance = False
    End If
    
    ' Loop thru the file until we get to the end of the autogenerated code
    Do
        ' read a record
        Line Input #hFile, strRecord
        
        ' remove any leading and trailing spaces
        strRecord = CleanUpData(strRecord)
        strTemp = Left$(strRecord, 10)
        
        ' see if we have found the first of occurance of "Attribute VB_"
        If blnFound1stOccurance Then
            If StrComp(strTemp, VB_ATTRIB, vbTextCompare) <> 0 Then
                ' We have now passed the autogenerated code
                Exit Do   ' exit Do..Loop
            End If
        Else
            If StrComp(strTemp, VB_ATTRIB, vbTextCompare) = 0 Then
                ' we found the first occurance
                blnFound1stOccurance = True
            End If
        End If
            
        If Len(strRecord) > 0 Then
            lngCount = lngCount + 1   ' Auto generated data
        Else
            lngBlanks = lngBlanks + 1 ' Blank record
        End If
        
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            Exit Do
        End If
        
    Loop While Not EOF(hFile)
    
Normal_Exit:
    ' Return the accumulated value
    AutoGen_Code = lngCount
  
End Function

' ***************************************************************************
' Routine:       SubRoutine
'
' Description:   Parses a record to see if it is a Sub routine in the VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function SubRoutine(ByVal strRecord As String, _
                            ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 4), "Sub ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 12), "Private Sub ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 11), "Friend Sub ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 11), "Public Sub ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 11), "Global Sub ", vbTextCompare) = 0 Then
       
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
           
        SubRoutine = True
    Else
        SubRoutine = False
    End If
 
End Function

' ***************************************************************************
' Routine:       FunctionRoutine
'
' Description:   Parses a record to see if it is a Function routine in the
'                VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function FunctionRoutine(ByVal strRecord As String, _
                                 ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 9), "Function ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 17), "Private Function ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 16), "Friend Function ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 16), "Public Function ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 16), "Global Function ", vbTextCompare) = 0 Then
       
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
           
        FunctionRoutine = True
    Else
        FunctionRoutine = False
    End If
 
End Function

' ***************************************************************************
' Routine:       API_Declare
'
' Description:   Parses a record to see if it is an API declare in the
'                VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function API_Declare(ByVal strRecord As String, _
                             ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 8), "Declare ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 16), "Private Declare ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 15), "Public Declare ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 15), "Global Declare ", vbTextCompare) = 0 Then
       
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
           
        API_Declare = True
    Else
        API_Declare = False
    End If
 
End Function

' ***************************************************************************
' Routine:       ConstantVar
'
' Description:   Parses a record to see if it is a constant variable in the
'                VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function ConstantVar(ByVal strRecord As String, _
                             ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 6), "Const ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 14), "Private Const ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 13), "Public Const ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 13), "Global Const ", vbTextCompare) = 0 Then
           
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
    
        ConstantVar = True
    Else
        ConstantVar = False
    End If
 
End Function

' ***************************************************************************
' Routine:       Type_Structure
'
' Description:   Parses a record to see if it is a type structure in the
'                VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function Type_Structure(ByVal strRecord As String, _
                                ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 5), "Type ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 13), "Private Type ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 12), "Public Type ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 12), "Global Type ", vbTextCompare) = 0 Then
           
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
        
        Type_Structure = True
    Else
        Type_Structure = False
    End If
    
End Function

' ***************************************************************************
' Routine:       Enum_Structure
'
' Description:   Parses a record to see if it is a Enum structure in the
'                VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function Enum_Structure(ByVal strRecord As String, _
                                ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 5), "Enum ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 13), "Private Enum ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 12), "Public Enum ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 12), "Global Enum ", vbTextCompare) = 0 Then
           
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
        
        Enum_Structure = True
    Else
        Enum_Structure = False
    End If
    
End Function

' ***************************************************************************
' Routine:       Comments
'
' Description:   Parses a record to see if it is a comment line in the
'                VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function Comments(ByVal strRecord As String, _
                          ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 1), "'", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 4), "Rem ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 10), "Attribute ", vbTextCompare) = 0 Then
           
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
        
        Comments = True
    Else
        Comments = False
    End If
 
End Function

' ***************************************************************************
' Routine:       PropertyLet
'
' Description:   Parses a record to see if it is a Property Let routine in
'                the VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function PropertyLet(ByVal strRecord As String, _
                             ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 13), "Property Let ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 21), "Private Property Let ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 20), "Friend Property Let ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 20), "Public Property Let ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 20), "Global Property Let ", vbTextCompare) = 0 Then
           
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
        
        PropertyLet = True
    Else
        PropertyLet = False
    End If
 
End Function

' ***************************************************************************
' Routine:       PropertyGet
'
' Description:   Parses a record to see if it is a Property Get routine in
'                the VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function PropertyGet(ByVal strRecord As String, _
                             ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 13), "Property Get ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 21), "Private Property Get ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 20), "Friend Property Get ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 20), "Public Property Get ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 20), "Global Property Get ", vbTextCompare) = 0 Then
           
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
        
        PropertyGet = True
    Else
        PropertyGet = False
    End If
 
End Function

' ***************************************************************************
' Routine:       PropertySet
'
' Description:   Parses a record to see if it is a Property Set routine in
'                the VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function PropertySet(ByVal strRecord As String, _
                             ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 13), "Property Set ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 21), "Private Property Set ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 20), "Friend Property Set ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 20), "Public Property Set ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 20), "Global Property Set ", vbTextCompare) = 0 Then
       
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
        
        PropertySet = True
    Else
        PropertySet = False
    End If
 
End Function

' ***************************************************************************
' Routine:       Events
'
' Description:   Parses a record to see if it is an Event routine in
'                the VB file
'
' Parameters:    strRecord - data string to parse
'                blnLineContinued - TRUE or FALSE if line has a continuation
'                                   character at the end ( _)
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function Events(ByVal strRecord As String, _
                        ByRef blnLineContinued As Boolean) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        ' Public Event
    ' Test the data string
    If StrComp(Left$(strRecord, 6), "Event ", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 13), "Public Event ", vbTextCompare) = 0 Then
       
        ' see if the line is continued
        If Right$(strRecord, 2) = " _" Then
            blnLineContinued = True
        End If
        
        Events = True
    Else
        Events = False
    End If
 
End Function

' ***************************************************************************
' Routine:       Trailer
'
' Description:   Parses a record to see if it is a trailer to a heading.
'                Example:    End Sub      End Function     End Property
'                            End Type     End If           Loop
'                            Wend         Next             End With
'                            End Select
'
' Parameters:    strRecord - data string to parse
'
' Returns:       TRUE or FALSE based on findings
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 29-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Add "End With", "End Select"
' ***************************************************************************
Private Function Trailer(ByVal strRecord As String) As Boolean

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    ' Test the data string
    If StrComp(Left$(strRecord, 12), "End Property", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 12), "End Function", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 7), "End Sub", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 8), "End With", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 10), "End Select", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 6), "End If", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 4), "Loop", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 4), "Wend", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 4), "Next", vbTextCompare) = 0 Or _
       StrComp(Left$(strRecord, 8), "End Type", vbTextCompare) = 0 Then
           
        Trailer = True
    Else
        Trailer = False
    End If
 
End Function

' ***************************************************************************
' Routine:       CleanUpData
'
' Description:   A data string is parsed and non-printable characters
'                are removed
'
' Parameters:    strData - data string to be evaluated
'
' Returns:       reformatted data string
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 01-NOV-2000  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' 01-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Modified and documented
' ***************************************************************************
Private Function CleanUpData(ByVal strData As String) As String

    Dim intIndex As Integer
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Function
    End If
        
    If Len(Trim$(strData)) = 0 Then
        GoTo CleanUpData_Exit
    End If
    
    strData = Trim$(strData)                  ' remove leading/trailing blanks
    strData = Replace(strData, Chr$(34), "")  ' remove all double quotes
    
    ' Loop thru data string and
    ' remove unwanted characters
    For intIndex = 0 To 31
        
        ' ignore the EOF and ESC characters
        If intIndex <> 26 Or intIndex <> 27 Then
            
            ' get rid of non-printable characters
            DoEvents
            strData = Replace(strData, Chr$(intIndex), "")
        End If
    
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            strData = vbNullString
            Exit For  ' exit loop
        End If
        
    Next intIndex
    
    strData = Trim$(strData)  ' remove leading/trailing blanks
    
CleanUpData_Exit:
    CleanUpData = strData     ' Return reformatted data
  
End Function

' **************************************************************************
' Routine:       SortCollection
'
' Description:   Sort the collection of data in ascending order.
'                    1.  transfer data from collection to an array
'                    2.  sort the array indices
'                    3.  empty the collection
'                    4.  copy the sort data back to the collection
'
' Parameters:    None
'
' Returns:       None
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 03-DEC-2004  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Sub SortCollection(ByRef colData As Collection)

    ' Called by GetFileList_DSW()
    '           GetFileList_VBG()
    '           Process_DSP_File()
    '           Process_VBP_File
    
    Dim lngIndex    As Long
    Dim astrTemp()  As String
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        Exit Sub
    End If
        
    Erase astrTemp()
    
    If colData.Count > 1 Then
        
        ReDim astrTemp(colData.Count - 1)
        
        ' transfer data from the collection to the temp array
        For lngIndex = 0 To colData.Count - 1
            
            astrTemp(lngIndex) = colData.Item(lngIndex + 1)
        
        Next lngIndex
                
        ' An error occurred or user opted to STOP processing
        DoEvents
        If gblnStopProcessing Then
            Exit Sub
        End If
            
        ' sort the array pointers in ascending order
        If CombSort(astrTemp()) Then
                
            Set colData = Nothing
            Set colData = New Collection
            
            ' load the collection with the sorted data
            For lngIndex = 0 To UBound(astrTemp)
                colData.Add astrTemp(lngIndex)
            Next lngIndex
        
        End If
        
        Erase astrTemp()
    
    End If
    
End Sub

' ***************************************************************************
' Procedure:     CombSort
'
' Description:   CombSort is faster than all but QuickSort and close to
'                it.  On the other hand, the code is much simpler than
'                QuickSort and can be easily customized for any array type.
'                The CombSort was first published by Richard Box and Stephen
'                Lacey in the April 1991 issue of Byte magazine. They found
'                that using a sequence for the gaps that decreased by a shrink
'                factor of 1.3 gave the best results. Trial and error produced
'                the refinement that an eventual gap size of 11, (rather than
'                9 or 10) gave a more efficient sequence of gaps below that
'                point.
'
'                Every programmer knows that QuickSort is the best in-memory
'                sort in the world. Look inside the sort function of almost
'                any library and you'll find QuickSort. Another thing that
'                every programmer knows is that BubbleSort, the "hello world"
'                of sorts, is one of the slowest in the world. But what most
'                programmers don't know is that a simple modification to
'                bubble sort turns it into CombSort, a remarkably simple sort
'                that's nearly as fast as QuickSort.
'
'                CombSort starts out comparing items that are far apart. Then
'                it makes the gap smaller and does it again. In the
'                algorithm's last passes the gap is 1, making it act
'                identical to BubbleSort. That makes it easy to see that this
'                algorithm is correct, since we know that BubbleSort is
'                correct and this algorithm always turns into BubbleSort.
'
' Parameters:    avntData - An array of unsorted data (byte, long, string)
'                blnAscending - Optional - Flag denoting if sorting is to be
'                     in ascending or descending order.
'                     Default = Ascending
'
' Returns:       A sorted array is TRUE if the sort was successful.
'
' ===========================================================================
'    DATE      NAME / DESCRIPTION
' -----------  --------------------------------------------------------------
' 21-May-2005  Kenneth Ives  kenaso@tx.rr.com
'              Wrote routine
' 08-JAN-2006  Kenneth Ives kenaso@tx.rr.com
'              Added error trapping
' 10-Feb-2008  Kenneth Ives kenaso@tx.rr.com
'              Made an assumption of the swapped flag being initialized to
'              FALSE.  Now, I manually set the flag prior to sorting.
' 01-Dec-2008  Kenneth Ives kenaso@tx.rr.com
'              Preventing a possible memory leak by emptying a variant when
'              it is not needed.
' 08-May-2010  Kenneth Ives kenaso@tx.rr.com
'              Added parameter denoting if sort should be in ascending or
'              descending order.
' ***************************************************************************
Public Function CombSort(ByRef avntData As Variant, _
                Optional ByVal blnAscending As Boolean = True) As Boolean
       
    ' Called by SortCollection()
    
    Dim lngGap     As Long
    Dim lngLow     As Long
    Dim lngHigh    As Long
    Dim lngIndex   As Long
    Dim vntHold    As Variant
    Dim blnSwapped As Boolean
    
    Const ROUTINE_NAME  As String = "CombSort"
    Const SHRINK_FACTOR As Double = 1.3
      
    On Error GoTo CombSort_Error

    CombSort = False  ' Preset to FALSE
    vntHold = Empty   ' Always start with empty variants
    
    If CBool(IsArrayInitialized(avntData)) Then
        
        lngLow = LBound(avntData)       ' Lowest number of elements
        lngHigh = UBound(avntData)      ' Highest number of elements
        lngGap = lngHigh - lngLow + 1   ' Total element count
        blnSwapped = False              ' Set swapped flag to FALSE
    
        ' too much overhead if only
        ' two items in the array
        If lngHigh <= 2 Then
            
            If blnAscending Then
                If (avntData(0) > avntData(1)) Then
                    SwapData avntData(0), avntData(1)
                End If
            End If
            
        Else
        
            Do
                If lngGap > 1 Then
                
                    ' Divide Gap by 1.3
                    lngGap = Int(lngGap / SHRINK_FACTOR)
                    
                    ' Most efficient series of
                    ' a final GAP starts with 11
                    If (lngGap = 9) Or _
                       (lngGap = 10) Then
                       
                        lngGap = 11
                    End If
                
                End If
                
                ' Preset flag to FALSE thus designating
                ' nothing has been swapped
                blnSwapped = False
                
                ' Compare and possibly swap values
                ' and pointers separated by GAP
                For lngIndex = lngLow To lngHigh - lngGap
                    
                    ' Capture current data for comparison
                    vntHold = avntData(lngIndex)
                    
                    ' Is hold data greater than current array data?
                    If (vntHold > avntData(lngIndex + lngGap)) Then
                        
                        ' Move data to new position within array
                        avntData(lngIndex) = avntData(lngIndex + lngGap)
                        avntData(lngIndex + lngGap) = vntHold
                        
                        vntHold = Empty    ' Empty holding area
                        blnSwapped = True  ' Reset swap flag
                        
                    End If
                   
                Next lngIndex
                
                ' An error occurred or user opted to STOP processing
                If gblnStopProcessing Then
                    Exit Do
                End If
            
            ' Loop until the GAP is less than one
            ' or nothing is swapped
            Loop Until lngGap = 1 And Not blnSwapped
        
            ' An error occurred or user opted to STOP processing
            If gblnStopProcessing Then
                GoTo CombSort_CleanUp
            End If
        
            ' If descending order is requested
            ' then reverse data within array
            If Not blnAscending Then
                
                Do While lngLow < lngHigh
                    
                    SwapData avntData(lngLow), avntData(lngHigh)  ' swap data elements
                    lngLow = lngLow + 1                           ' increment low index
                    lngHigh = lngHigh - 1                         ' decrement high index
                
                Loop
            End If
        End If
    End If
    
CombSort_CleanUp:
    vntHold = Empty   ' Always empty variants when not needed

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        CombSort = False   ' Bad finish
    Else
        CombSort = True    ' Successful completion
    End If
    
    On Error GoTo 0   ' Nullify this error trap
    Exit Function

CombSort_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    gblnStopProcessing = True
    Resume CombSort_CleanUp

End Function

' ***************************************************************************
' Routine:       SwapData
'
' Description:   Swap data with each other.  I wrote this function since
'                BASIC stopped having its own SWAP function.
'
' Parameters:    vntValue1 - Incoming data to be swapped with Value2
'                vntValue2 - Incoming data to be swapped with Value1
'
' Returns:       Swapped data
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 09-NOV-2002  Kenneth Ives  kenaso@tx.rr.com
'              Original
' ***************************************************************************
Private Sub SwapData(ByRef vntData1 As Variant, _
                     ByRef vntData2 As Variant)

    Dim vntHold As Variant

    vntHold = Empty   ' Start with empty variants (prevents crashing)

    vntHold = vntData1
    vntData1 = vntData2
    vntData2 = vntHold

    vntHold = Empty   ' Always empty variants (prevents crashing)

End Sub
Private Sub CreateReport()

    ' Called by BeginProcessing()
    
    Dim hFile        As Long
    Dim strText      As String
    Dim strFileName  As String
    Dim strLeftSide  As String
    Dim strRightSide As String
    Dim objKeyEdit   As cKeyEdit
    
    Const ROUTINE_NAME As String = "CreateReport"

    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo CreateReport_CleanUp
    End If
        
    On Error GoTo CreateReport_Error

    Set objKeyEdit = New cKeyEdit   ' Instantiate class object
    
    ' Create the report file
    hFile = FreeFile
    Open mstrRptFile For Output As #hFile
    
    With objKeyEdit
        ' Format top title line in report
        ' followed by one blank line
        strLeftSide = gstrVersion
        strRightSide = Format$(Now(), "d MMM yyyy") & "  " & Format$(Now(), "Medium Time")
        strText = .CenterReportText(RPT_LINE_LENGTH, , strLeftSide, strRightSide)
        Print #hFile, strText & vbNewLine
            
        ' Capture name of main file only
        strFileName = GetFilename(mstrPathAndFile)
        strFileName = ShrinkToFit(strFileName, RPT_LINE_LENGTH)
        strText = .CenterReportText(RPT_LINE_LENGTH, strFileName)
        Print #hFile, strText
        
        ' Optional title line designating who
        ' requested or where report is destined
        If Len(gstrOptTitle) > 0 Then
            strText = .CenterReportText(RPT_LINE_LENGTH, gstrOptTitle)
            Print #hFile, strText
        End If
    End With
    
    ' Dashes at bottom of report headings
    ' followed by one blank line
    Print #hFile, String(RPT_LINE_LENGTH, "-") & vbNewLine
    
CreateReport_CleanUp:
    Close #hFile              ' Close file handle
    Set objKeyEdit = Nothing  ' Always free objects from memory when not needed
    On Error GoTo 0
    Exit Sub

CreateReport_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    gblnStopProcessing = True
    Resume CreateReport_CleanUp

End Sub

Private Sub AppendReport()
    
    ' Called by ProcessFiles_DSP()
    '           ProcessFiles_VBP()
    '           Process_DSP()
    '           Process_VBP()
    '           Process_Other()
    
    Dim hFile   As Long
    Dim strData As String
    
    Const ROUTINE_NAME As String = "AppendReport"
    
    ' An error occurred or user opted to STOP processing
    DoEvents
    If gblnStopProcessing Then
        GoTo AppendReport_CleanUp
    End If
        
    On Error GoTo AppendReport_Error

    ' Save overall line count to output
    ' file along with a short message
    hFile = FreeFile                        ' Get first free file handle
    Open mstrRptFile For Append As #hFile   ' Open report to append closing data
    
    strData = vbNullString  ' Start with an empty variable
    strData = strData & Space$(10) & String$(10, "=") & vbNewLine
    strData = strData & Space$(10) & _
                        Format(Format(mlngGrandTotal, "#,0"), FMT_LINE) & _
                        "  Total number of lines of code"
    strData = strData & vbNewLine & vbNewLine
    strData = strData & String$(RPT_LINE_LENGTH, "*") & vbNewLine
    
    If mblnVisualBasic Then
        strData = strData & "NOTE:     Visual Basic trailers are not counted.  These are the" & vbNewLine
        strData = strData & Space$(10) & "logical ending statements used by proceedural headings."
        strData = strData & vbNewLine & vbNewLine
        strData = strData & Space$(15) & "End Sub     End Function     End Property" & vbNewLine
        strData = strData & Space$(15) & "End If      End Type         Loop" & vbNewLine
        strData = strData & Space$(15) & "Next        Wend             End With" & vbNewLine
        strData = strData & Space$(15) & "End Select" & vbNewLine
    Else
        strData = strData & "NOTE:     Items NOT counted in C are BRACES( '{' and '}' ) on a" & vbNewLine
        strData = strData & Space$(10) & "line by themselves or they are the first character" & vbNewLine
        strData = strData & Space$(10) & "followed by a semicolon or a comment indicator." & vbNewLine
    End If
    
    strData = strData & String$(RPT_LINE_LENGTH, "*")
    strData = strData & vbNewLine & vbNewLine
    
    Print #hFile, strData
    
AppendReport_CleanUp:
    Close #hFile
    strData = vbNullString
    mlngGrandTotal = 0
    ZeroMemory mtypSTATS, Len(mtypSTATS)   ' Empty statistics counter structure
    Exit Sub
    
AppendReport_Error:
    ErrorMsg MODULE_NAME, ROUTINE_NAME, Err.Description
    Close        
    gblnStopProcessing = True
    Resume AppendReport_CleanUp
    
End Sub

Private Function CountFolders(ByRef strFileName As String) As Long

    ' Called By GetFileList_DSW()
    '           GetFileList_VBG()
    '           Process_DSP_File()
    '           Process_VBP_File()
    
    Dim lngIndex    As Long
    Dim lngCount    As Long
    Dim lngPosition As Long
    
    lngCount = 0
    lngPosition = 1
    
    For lngIndex = 1 To 99
        If StrComp("..\", Mid$(strFileName, lngPosition, 3)) = 0 Then
            lngCount = lngCount + 1
            lngPosition = lngPosition + 3
        Else
            Exit For
        End If
    Next lngIndex
           
    ' Resize file name
    If lngCount > 0 Then
        strFileName = Mid$(strFileName, lngPosition)
        CountFolders = lngCount
    End If
    
End Function

' ***************************************************************************
' Routine:       CreateTempFile
'
' Description:   System generated temporary folder and file.  The folder
'                will be located in the Windows default temp directory and
'                is system generated.
'
'                If processing UNIX based C code, you will notice that in
'                MS-DOS the lines are contiguous and rarely have any
'                linefeed characters (Chr$(10).  Therefore, I am staying on
'                the safe side of caution and creating a temporary file with
'                which to work.  A temporary file is created and then the
'                contents of the source code are transferred to it.  This way,
'                if any problems arise, the original code is not damaged.
'
' Parameters:    strPathAndFile - Path to a folder.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 10-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function CreateTempFile(ByVal strPathAndFile As String) As String

    ' Called by Read_C_File()
    
    Dim strFile   As String
    Dim strPath   As String
    Dim strBuffer As String
    Dim hFile1    As Long
    Dim hFile2    As Long

    Const FILE_PREFIX As String = "~ki"  ' User defined prefix

    strFile = Space$(MAX_SIZE)  ' preload with spaces, not nulls

    ' Locate Windows default temp folder. This
    ' is where Windows creates its temp files.
    strPath = GetTempFolder()
    
    ' capture temp path for clean up later
    gstrTempPath = strPath
    
    ' Create a unique temporary file name.
    ' A hex value is returned by the system.
    ' Ex:  "C:\DOCUME~1\Kenaso\LOCALS~1\Temp\~ki99.tmp"
    GetTempFileName strPath, FILE_PREFIX, 0, strFile

    strFile = TrimStr(strFile)     ' Remove any trailing nulls
    
    hFile1 = FreeFile                          ' Get first free file handle
    Open strPathAndFile For Input As #hFile1   ' Open original file for read only
    
    hFile2 = FreeFile                          ' Get next free file handle
    Open strFile For Output As #hFile2         ' Create empty file to receive data
    
    ' Transfer data from C source
    ' code to temp work file
    Do While Not EOF(hFile1)
    
        strBuffer = vbNullString                  ' Verify buffer is empty
        Line Input #hFile1, strBuffer   ' Capture data from original file
        
        ' Search for carriage return [Chr$(13)]
        ' characters in this string of data
        If InStr(1, strBuffer, Chr$(13)) > 0 Then
        
            ' Remove all carriage returns [Chr$(13)]
            strBuffer = Replace(strBuffer, Chr$(13), "")
        End If
        
        ' Search for any linefeed [Chr$(10)]
        ' characters in this string of data
        If InStr(1, strBuffer, Chr$(10)) > 0 Then
            
            ' Replace all linefeeds [Chr$(10)]
            ' with Chr$(13)+Chr$(10)
            strBuffer = Replace(strBuffer, Chr$(10), vbNewLine)
        End If
        
        Print #hFile2, strBuffer   ' Write buffer to temp file
        
    Loop
    
    Close #hFile1  ' Close both files
    Close #hFile2
    
    CreateTempFile = strFile  ' Return path\name of temp file
    
    strFile = vbNullString   ' Empty variables
    strPath = vbNullString
    strBuffer = vbNullString

End Function

' ***************************************************************************
' Routine:       GetTempFolder
'
' Description:   Find system generated temporary folder.
'
' Returns:       Path to the windows default temp folder
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 10-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Routine created
' ***************************************************************************
Private Function GetTempFolder() As String

    ' Called by CreateTempFile()
    
    Dim strTempFolder As String
    Dim lngRetCode    As Long

    strTempFolder = Space$(MAX_SIZE)   ' preload with spaces, not nulls

    lngRetCode = GetTempPath(MAX_SIZE, strTempFolder)  ' read the path name

    ' Extract data from the variable
    ' Ex:  "C:\DOCUME~1\Kenaso\LOCALS~1\Temp\"
    If lngRetCode Then
        ' Found Windows default Temp folder.  Remove
        ' any trailing nulls and append backslash
        strTempFolder = TrimStr(strTempFolder)
        strTempFolder = QualifyPath(strTempFolder)
    Else
        ' Did not find Windows default temp folder
        ' therefore, use root level of drive C:
        strTempFolder = "C:\"   ' should never happen
    End If

    GetTempFolder = strTempFolder   ' Return path to temp folder
    
    strTempFolder = vbNullString   ' Empty variables

End Function

' ***************************************************************************
' Routine:       CleanUpTempFolder
'
' Description:   Searches temp folder for all files prefixed with a specific
'                set of characters and deletes that particular file.
'
' ===========================================================================
'    DATE      NAME / eMAIL
'              DESCRIPTION
' -----------  --------------------------------------------------------------
' 17-Oct-2010  Kenneth Ives  kenaso@tx.rr.com
'              Wrote routine
' ***************************************************************************
Private Sub CleanUpTempFolder()

    ' Called by BeginProcessing()
    
    Dim objFSO    As Scripting.FileSystemObject
    Dim objFile   As File
    Dim objFolder As Folder
    
    ' Instantiate objects
    Set objFSO = New Scripting.FileSystemObject
    Set objFolder = objFSO.GetFolder(gstrTempPath)
    
    For Each objFile In objFolder.Files
        
        ' Test just file name
        If StrComp(Left$(objFile.Name, 3), TMP_PREFIX, vbTextCompare) = 0 Then
        
            ' remove file using full path\file name
            objFSO.DeleteFile objFile
        End If
        
    Next
    
    ' Always free objects when not needed.
    ' This helps to prevent memory leaks
    ' and memory fragmentation
    Set objFile = Nothing
    Set objFolder = Nothing
    Set objFSO = Nothing
    
End Sub

